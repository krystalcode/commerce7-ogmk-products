<?php
/**
 * @file
 * Code for the Commerce Marketplace Products feature.
 */

include_once 'ogmk_products.features.inc';

/**
 * Hooks.
 */

/**
 * Implements hook_theme().
 */
function ogmk_products_theme($existing, $type, $theme, $path) {
  return array(
    'user_orders_page' => array(
      'variables' => array('variables' => NULL),
      'template'  => 'templates/pages/user-orders',
    ),
  );
}

/**
 * Implements hook_entity_info_alter().
 */
function ogmk_products_entity_info_alter(&$entity_info) {
  /**
   * @Issue(
   *   "Maybe this should be moved to a base ogmk module"
   *   type="task"
   *   priority="low"
   *   labels="modularity"
   * )
   */
  $entity_info['node']['view modes']['ogmk_bootstrap_media'] = array(
    'label' => t('OGMK Bootstrap Media'),
    'custom settings' => FALSE,
  );
}

/**
 * Implements hook_commerce_line_item_type_info().
 *
 * Provides a custom line item type for 'ogmk_product' products.
 */
function ogmk_products_commerce_line_item_type_info() {
  $line_item_types = array();

  $line_item_types['ogmk_product'] = array(
    'name' => t('Product'),
    'description' => t('Line item for OGMK products'),
    'product' => TRUE,
    'add_form_submit_value' => t('Add product'),
    'base' => 'commerce_product_line_item',
    'callbacks' => array(
      'title' => '_ogmk_products_line_item_title__ogmk_product',
    ),
  );

  return $line_item_types;
}

/**
 * Implements hook_node_insert().
 */
function ogmk_products_node_insert($node) {
  _ogmk_products_generate_skus($node);
}

/**
 * Implements hook_node_update().
 */
function ogmk_products_node_update($node) {
  _ogmk_products_generate_skus($node);
}

/**
 * Callbacks.
 */

/**
 * Line item title callback.
 *
 * @Issue(
 *   "Take into account internationalisation as well"
 *   type="bug"
 *   priority="low"
 *   labels="internationalisation"
 * )
 */
function _ogmk_products_line_item_title__ogmk_product($line_item) {
  $product_id = (int) $line_item->commerce_product[LANGUAGE_NONE][0]['product_id'];
  $node = ogmk_products_product_get_node($product_id);

  $title = check_plain($node->title);

  if (count($node->ogmk_products_ref[LANGUAGE_NONE]) > 1) {
    $product = commerce_product_load($product_id);
    $title .= ', ' . check_plain($product->title);
  }

  return $title;
}

/**
 * Public API.
 */

/**
 * @param int|object $product
 *   The product id or object for whom to check if there is a referencing node.
 * @param string $node_type
 *   The node type to look for.
 *
 * @return int
 *   Zero (0) if there is no node referencing the product.
 *   The node's id otherwise.
 */
function ogmk_products_product_has_node($product, $node_type = 'ogmk_product') {
  $productId = NULL;
  if (is_int($product)) {
    $productId = $product;
  } else {
    $productId = $product->product_id;
  }

  // Get the "product" node that corresponds to the given "commerce_product"
  // entity.
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node', '=')
    ->propertyCondition('type', $node_type)
    ->fieldCondition('ogmk_products_ref', 'product_id', $productId, '=');
  $result = $query->execute();

  if (empty($result['node'])) {
    return 0;
  }

  // Get the first key of the result array because there should be only one
  // result.
  return key($result['node']);
}

/**
 * @param int|object $product
 *   The product id or object for whom to check if there is a referencing node.
 * @param string $node_type
 *   The node type to look for.
 *
 * @return null|object
 *   NULL if there is no node referencing the product.
 *   The node's object otherwise.
 */
function ogmk_products_product_get_node($product, $node_type = 'ogmk_product') {
  $nodeId = ogmk_products_product_has_node($product, $node_type);

  if ($nodeId) {
    return node_load($nodeId);
  }

  return NULL;
}

/**
 * Functions for internal use.
 */

/**
 * Set the SKU for a created or updated product variant.
 *
 * Generate and save the SKU for commerce_product entities, so that they follow
 * the pattern 'S%shop_id%P%product_id%V%variant_id%', where 'product_id' is the
 * corresponding node id and 'variant_id' is the commerce product's id.
 *
 * This function is expecting the product node as an argument and is being
 * called by hook_node_insert/update() hooks. We do so, instead of using
 * hook_entity_insert/update() hooks for the inserted/updated commerce_product
 * entities, because the variants are created using inline entity forms and they
 * may orphaned variants (without a shop or product node association) until the
 * product node is actually saved.
 *
 * @param object $node The product node that holds the variants for which SKUs
 *                     will be generated.
 *
 * @Issue(
 *   "Support customisation of the SKU pattern through an api hook and/or a
 *   system variable"
 *   type="improvement"
 *   priority="low"
 *   labels="modularity"
 * )
 */
function _ogmk_products_generate_skus($node) {
  if ($node->type !== 'ogmk_product') {
    return;
  }

  $node_wrapper = entity_metadata_wrapper('node', $node);
  $variants = $node_wrapper->ogmk_products_ref->value();

  // Nothing to do if the product has no variants yet.
  if (empty($variants)) {
    return;
  }

  // We will need the shop id.
  /**
   * @Issue(
   *   "Get the shop identifier only instead of loading the full node"
   *   type="improvement"
   *   priority="low"
   *   labels="performance"
   * )
   */
  $shop = $node_wrapper->ogmk_shop_ref->value();

  // Generate and save the SKU for each variant.
  foreach ($variants as $variant) {
    // When the variant is first created, it contains a timestamp-based number
    // as the SKU. If the SKU starts with 'S', we have already generated the SKU
    // for the variant - we don't need to do it again.
    if (strpos($variant->sku, 'S') === 0) {
      continue;
    }

    // Generate the SKU and save the variant.
    $variant->sku = 'S' . $shop->nid . 'P' . $node->nid . 'V' . $variant->product_id;
    entity_save('commerce_product', $variant);
  }
}
